/*
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在额外使用O(1)额外空间的条件下完成。
示例：给定nums = [0,0,1,1,1,2,2,3,3,4]，函数应该返回新的长度5，并且原数组nums的前5个元素被修改为0,1,2,3,4。你不需要考虑数组中超出新长度后面的元素
说明：为什么返回数值是整数，但输出的答案是数组呢？请注意，输入数组是引用方式传递的，不对实参做任何拷贝，这意味着在函数里修改输入数组对于调用者是可见的。
*/

/*方法：双指针法
数组完成排序后，放置快指针i和慢指针j，只要nums[i]=nums[j]，我们就增加j以跳过重复项，当我们遇到nums[i]!=nums[j]时，跳过重复项运行已经结束，因此我们必须把nums[j]复制到nums[i+1]，然后递增i，接着我们将再次重复相同的过程，直到j到达数组的末尾为止。
时间复杂度：O(n) 假设数组的长度是n，那么i和j分别最多遍历n步。
空间复杂度：O(1) 
*/

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        int i = 0;
        for(int j=1;j<nums.size();j++)
        {
            if(nums[i] != nums[j])
            {
                i++;
                nums[i] = nums[j];
            }
        }
        return i+1;
    }
};
