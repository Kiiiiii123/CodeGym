/*
给定一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用O(1)额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例：给定nums = [0,1,2,2,3,0,4,2]，val = 2，函数应该返回新的长度5，并且nums中的前5个元素为0,1,3,9,4,。注意这五个元素为任意顺序，你不需要考虑数组中超出新长度后面的元素。
说明：为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
*/

/*方法一：双指针
设置慢指针ｉ和快指针ｊ，当nums[i]与给定的值相等时，递增ｊ以跳过该元素，只要nums[j]!=val，我们就复制nums[j]到nums[i]并同时递增两个索引，重复这一过程，直到ｊ到达数组的末尾，该数组的新长度为ｉ。
时间复杂度：Ｏ(n)　假设数组总共有ｎ个元素，ｉ和ｊ至少遍历２ｎ步。
空间复杂度：Ｏ(1)
*/

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size() == 0) return 0;
        int i = 0;
        for(int j=0;j<nums.size();j++)
        {
            if(nums[j] != val)
            {
                nums[i] = nums[j];
                i++;
            }
        }
        return i;
    }
};

/*方法二：双指针－－当要删除的元素很少时
思路：现在考虑数组包含很少的要删除的元素的情况。例如，nums = [1,2,3,5,4],val = 4。之前的算法会对其余元素做必要的复制操作。另一个例子是nums = [4,1,2,3,5],val = 4。似乎灭有必要将[1,2,3,5]这几个元素左移一步，因为问题描述中提到元素顺序可以更改。
算法：当我们遇到nums[i]＝val时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素，这实际上使数组的大小减少了１。请注意，被交换的最后一个元素可能是您想要移除的值，但是不要担心，在下一次的迭代中，我们仍然会检查这个元素。
时间复杂度：Ｏ(n) ｉ和ｎ最多遍历ｎ步，在这个方法中，赋值操作的次数等于要删除的元素的数量，因此，如果要移除的元素很少，效率会更高。
空间复杂度：Ｏ(1)
*/

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size() == 0) return 0;
        int i = 0;
        int length = nums.size();
        while(i<length)
        {
            if(nums[i] == val)
            {
                nums[i] = nums[length-1];
                length--;
            }
            else
                i++;
        }
        return length;
    }
};
